// Code generated by github.com/hooto/protobuf_slice
// source: ns-service.proto
// DO NOT EDIT!

package inapi

import "sync"

var object_slice_mu_NsPodServiceHost sync.RWMutex

func (it *NsPodServiceHost) Equal(it2 *NsPodServiceHost) bool {
	if it2 == nil ||
		it.Rep != it2.Rep ||
		it.Ip != it2.Ip ||
		it.Port != it2.Port {
		return false
	}
	return true
}

func (it *NsPodServiceHost) Sync(it2 *NsPodServiceHost) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Rep != it2.Rep {
		it.Rep, changed = it2.Rep, true
	}
	if it.Ip != it2.Ip {
		it.Ip, changed = it2.Ip, true
	}
	if it.Port != it2.Port {
		it.Port, changed = it2.Port, true
	}
	return changed
}

func NsPodServiceHostSliceGet(ls []*NsPodServiceHost, arg_rep uint32) *NsPodServiceHost {
	object_slice_mu_NsPodServiceHost.RLock()
	defer object_slice_mu_NsPodServiceHost.RUnlock()

	for _, v := range ls {
		if v.Rep == arg_rep {
			return v
		}
	}
	return nil
}

func NsPodServiceHostSliceEqual(ls, ls2 []*NsPodServiceHost) bool {
	object_slice_mu_NsPodServiceHost.RLock()
	defer object_slice_mu_NsPodServiceHost.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Rep != v2.Rep {
				continue
			}
			if v.Ip != v2.Ip {
				return false
			}
			if v.Port != v2.Port {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func NsPodServiceHostSliceSync(ls []*NsPodServiceHost, it2 *NsPodServiceHost) ([]*NsPodServiceHost, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_NsPodServiceHost.Lock()
	defer object_slice_mu_NsPodServiceHost.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Rep != it2.Rep {
			continue
		}
		if v.Ip != it2.Ip {
			v.Ip, changed = it2.Ip, true
		}
		if v.Port != it2.Port {
			v.Port, changed = it2.Port, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func NsPodServiceHostSliceSyncSlice(ls, ls2 []*NsPodServiceHost) ([]*NsPodServiceHost, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_NsPodServiceHost.Lock()
	defer object_slice_mu_NsPodServiceHost.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Rep != v2.Rep {
				continue
			}
			if v.Ip != v2.Ip {
				v.Ip, changed = v2.Ip, true
			}
			if v.Port != v2.Port {
				v.Port, changed = v2.Port, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_NsPodServiceEntry sync.RWMutex

func (it *NsPodServiceEntry) Equal(it2 *NsPodServiceEntry) bool {
	if it2 == nil ||
		it.Port != it2.Port ||
		!NsPodServiceHostSliceEqual(it.Items, it2.Items) {
		return false
	}
	return true
}

func (it *NsPodServiceEntry) Sync(it2 *NsPodServiceEntry) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Port != it2.Port {
		it.Port, changed = it2.Port, true
	}
	if rs, ok := NsPodServiceHostSliceSyncSlice(it.Items, it2.Items); ok {
		it.Items, changed = rs, true
	}
	return changed
}

func NsPodServiceEntrySliceGet(ls []*NsPodServiceEntry, arg_port uint32) *NsPodServiceEntry {
	object_slice_mu_NsPodServiceEntry.RLock()
	defer object_slice_mu_NsPodServiceEntry.RUnlock()

	for _, v := range ls {
		if v.Port == arg_port {
			return v
		}
	}
	return nil
}

func NsPodServiceEntrySliceEqual(ls, ls2 []*NsPodServiceEntry) bool {
	object_slice_mu_NsPodServiceEntry.RLock()
	defer object_slice_mu_NsPodServiceEntry.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Port != v2.Port {
				continue
			}
			if !NsPodServiceHostSliceEqual(v.Items, v2.Items) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func NsPodServiceEntrySliceSync(ls []*NsPodServiceEntry, it2 *NsPodServiceEntry) ([]*NsPodServiceEntry, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_NsPodServiceEntry.Lock()
	defer object_slice_mu_NsPodServiceEntry.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Port != it2.Port {
			continue
		}
		if rs, ok := NsPodServiceHostSliceSyncSlice(v.Items, it2.Items); ok {
			v.Items, changed = rs, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func NsPodServiceEntrySliceSyncSlice(ls, ls2 []*NsPodServiceEntry) ([]*NsPodServiceEntry, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_NsPodServiceEntry.Lock()
	defer object_slice_mu_NsPodServiceEntry.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Port != v2.Port {
				continue
			}
			if rs, ok := NsPodServiceHostSliceSyncSlice(v.Items, v2.Items); ok {
				v.Items, changed = rs, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_NsPodServiceMap sync.RWMutex

func (it *NsPodServiceMap) Equal(it2 *NsPodServiceMap) bool {
	if it2 == nil ||
		it.Id != it2.Id ||
		it.User != it2.User ||
		!NsPodServiceEntrySliceEqual(it.Services, it2.Services) ||
		it.Updated != it2.Updated {
		return false
	}
	return true
}

func (it *NsPodServiceMap) Sync(it2 *NsPodServiceMap) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Id != it2.Id {
		it.Id, changed = it2.Id, true
	}
	if it.User != it2.User {
		it.User, changed = it2.User, true
	}
	if rs, ok := NsPodServiceEntrySliceSyncSlice(it.Services, it2.Services); ok {
		it.Services, changed = rs, true
	}
	if it.Updated != it2.Updated {
		it.Updated, changed = it2.Updated, true
	}
	return changed
}

func NsPodServiceMapSliceGet(ls []*NsPodServiceMap, arg_id string) *NsPodServiceMap {
	object_slice_mu_NsPodServiceMap.RLock()
	defer object_slice_mu_NsPodServiceMap.RUnlock()

	for _, v := range ls {
		if v.Id == arg_id {
			return v
		}
	}
	return nil
}

func NsPodServiceMapSliceEqual(ls, ls2 []*NsPodServiceMap) bool {
	object_slice_mu_NsPodServiceMap.RLock()
	defer object_slice_mu_NsPodServiceMap.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Id != v2.Id {
				continue
			}
			if v.User != v2.User {
				return false
			}
			if !NsPodServiceEntrySliceEqual(v.Services, v2.Services) {
				return false
			}
			if v.Updated != v2.Updated {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func NsPodServiceMapSliceSync(ls []*NsPodServiceMap, it2 *NsPodServiceMap) ([]*NsPodServiceMap, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_NsPodServiceMap.Lock()
	defer object_slice_mu_NsPodServiceMap.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Id != it2.Id {
			continue
		}
		if v.User != it2.User {
			v.User, changed = it2.User, true
		}
		if rs, ok := NsPodServiceEntrySliceSyncSlice(v.Services, it2.Services); ok {
			v.Services, changed = rs, true
		}
		if v.Updated != it2.Updated {
			v.Updated, changed = it2.Updated, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func NsPodServiceMapSliceSyncSlice(ls, ls2 []*NsPodServiceMap) ([]*NsPodServiceMap, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_NsPodServiceMap.Lock()
	defer object_slice_mu_NsPodServiceMap.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Id != v2.Id {
				continue
			}
			if v.User != v2.User {
				v.User, changed = v2.User, true
			}
			if rs, ok := NsPodServiceEntrySliceSyncSlice(v.Services, v2.Services); ok {
				v.Services, changed = rs, true
			}
			if v.Updated != v2.Updated {
				v.Updated, changed = v2.Updated, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}
