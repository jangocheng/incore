// Code generated by github.com/hooto/protobuf_slice
// source: stats.proto
// DO NOT EDIT!

package inapi

import "sync"

var object_slice_mu_PbStatsSampleFeed sync.RWMutex

func (it *PbStatsSampleFeed) Equal(it2 *PbStatsSampleFeed) bool {
	if it2 == nil ||
		it.Kind != it2.Kind ||
		it.Cycle != it2.Cycle ||
		!PbStatsSampleEntrySliceEqual(it.Items, it2.Items) {
		return false
	}
	return true
}

func (it *PbStatsSampleFeed) Sync(it2 *PbStatsSampleFeed) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbStatsSampleFeedSliceGet(ls []*PbStatsSampleFeed, arg_cycle uint32) *PbStatsSampleFeed {
	object_slice_mu_PbStatsSampleFeed.RLock()
	defer object_slice_mu_PbStatsSampleFeed.RUnlock()

	for _, v := range ls {
		if v.Cycle == arg_cycle {
			return v
		}
	}
	return nil
}

func PbStatsSampleFeedSliceDel(ls []*PbStatsSampleFeed, arg_cycle uint32) ([]*PbStatsSampleFeed, bool) {
	object_slice_mu_PbStatsSampleFeed.Lock()
	defer object_slice_mu_PbStatsSampleFeed.Unlock()
	for i, v := range ls {
		if v.Cycle == arg_cycle {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbStatsSampleFeedSliceEqual(ls, ls2 []*PbStatsSampleFeed) bool {
	object_slice_mu_PbStatsSampleFeed.RLock()
	defer object_slice_mu_PbStatsSampleFeed.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Cycle != v2.Cycle {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbStatsSampleFeedSliceSync(ls []*PbStatsSampleFeed, it2 *PbStatsSampleFeed) ([]*PbStatsSampleFeed, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbStatsSampleFeed.Lock()
	defer object_slice_mu_PbStatsSampleFeed.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.Cycle != it2.Cycle {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbStatsSampleFeedSliceSyncSlice(ls, ls2 []*PbStatsSampleFeed) ([]*PbStatsSampleFeed, bool) {
	if PbStatsSampleFeedSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbStatsSampleEntry sync.RWMutex

func (it *PbStatsSampleEntry) Equal(it2 *PbStatsSampleEntry) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		!PbStatsSampleValueSliceEqual(it.Items, it2.Items) {
		return false
	}
	return true
}

func (it *PbStatsSampleEntry) Sync(it2 *PbStatsSampleEntry) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbStatsSampleEntrySliceGet(ls []*PbStatsSampleEntry, arg_name string) *PbStatsSampleEntry {
	object_slice_mu_PbStatsSampleEntry.RLock()
	defer object_slice_mu_PbStatsSampleEntry.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbStatsSampleEntrySliceDel(ls []*PbStatsSampleEntry, arg_name string) ([]*PbStatsSampleEntry, bool) {
	object_slice_mu_PbStatsSampleEntry.Lock()
	defer object_slice_mu_PbStatsSampleEntry.Unlock()
	for i, v := range ls {
		if v.Name == arg_name {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbStatsSampleEntrySliceEqual(ls, ls2 []*PbStatsSampleEntry) bool {
	object_slice_mu_PbStatsSampleEntry.RLock()
	defer object_slice_mu_PbStatsSampleEntry.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbStatsSampleEntrySliceSync(ls []*PbStatsSampleEntry, it2 *PbStatsSampleEntry) ([]*PbStatsSampleEntry, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbStatsSampleEntry.Lock()
	defer object_slice_mu_PbStatsSampleEntry.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbStatsSampleEntrySliceSyncSlice(ls, ls2 []*PbStatsSampleEntry) ([]*PbStatsSampleEntry, bool) {
	if PbStatsSampleEntrySliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbStatsSampleValue sync.RWMutex

func (it *PbStatsSampleValue) Equal(it2 *PbStatsSampleValue) bool {
	if it2 == nil ||
		it.Time != it2.Time ||
		it.Value != it2.Value {
		return false
	}
	return true
}

func (it *PbStatsSampleValue) Sync(it2 *PbStatsSampleValue) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbStatsSampleValueSliceGet(ls []*PbStatsSampleValue, arg_time uint32) *PbStatsSampleValue {
	object_slice_mu_PbStatsSampleValue.RLock()
	defer object_slice_mu_PbStatsSampleValue.RUnlock()

	for _, v := range ls {
		if v.Time == arg_time {
			return v
		}
	}
	return nil
}

func PbStatsSampleValueSliceDel(ls []*PbStatsSampleValue, arg_time uint32) ([]*PbStatsSampleValue, bool) {
	object_slice_mu_PbStatsSampleValue.Lock()
	defer object_slice_mu_PbStatsSampleValue.Unlock()
	for i, v := range ls {
		if v.Time == arg_time {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbStatsSampleValueSliceEqual(ls, ls2 []*PbStatsSampleValue) bool {
	object_slice_mu_PbStatsSampleValue.RLock()
	defer object_slice_mu_PbStatsSampleValue.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Time != v2.Time {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbStatsSampleValueSliceSync(ls []*PbStatsSampleValue, it2 *PbStatsSampleValue) ([]*PbStatsSampleValue, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbStatsSampleValue.Lock()
	defer object_slice_mu_PbStatsSampleValue.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.Time != it2.Time {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbStatsSampleValueSliceSyncSlice(ls, ls2 []*PbStatsSampleValue) ([]*PbStatsSampleValue, bool) {
	if PbStatsSampleValueSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}
