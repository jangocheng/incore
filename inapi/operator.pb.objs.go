// Code generated by github.com/hooto/protobuf_slice
// source: operator.proto
// DO NOT EDIT!

package inapi

import "sync"

var object_slice_mu_PbOpLogEntry sync.RWMutex

func (it *PbOpLogEntry) Equal(it2 *PbOpLogEntry) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.Status != it2.Status ||
		it.Updated != it2.Updated ||
		it.Message != it2.Message {
		return false
	}
	return true
}

func (it *PbOpLogEntry) Sync(it2 *PbOpLogEntry) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.Status != it2.Status {
		it.Status, changed = it2.Status, true
	}
	if it.Updated != it2.Updated {
		it.Updated, changed = it2.Updated, true
	}
	if it.Message != it2.Message {
		it.Message, changed = it2.Message, true
	}
	return changed
}

func PbOpLogEntrySliceGet(ls []*PbOpLogEntry, arg_name string) *PbOpLogEntry {
	object_slice_mu_PbOpLogEntry.RLock()
	defer object_slice_mu_PbOpLogEntry.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbOpLogEntrySliceEqual(ls, ls2 []*PbOpLogEntry) bool {
	object_slice_mu_PbOpLogEntry.RLock()
	defer object_slice_mu_PbOpLogEntry.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if v.Status != v2.Status {
				return false
			}
			if v.Updated != v2.Updated {
				return false
			}
			if v.Message != v2.Message {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbOpLogEntrySliceSync(ls []*PbOpLogEntry, it2 *PbOpLogEntry) ([]*PbOpLogEntry, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbOpLogEntry.Lock()
	defer object_slice_mu_PbOpLogEntry.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if v.Status != it2.Status {
			v.Status, changed = it2.Status, true
		}
		if v.Updated != it2.Updated {
			v.Updated, changed = it2.Updated, true
		}
		if v.Message != it2.Message {
			v.Message, changed = it2.Message, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbOpLogEntrySliceSyncSlice(ls, ls2 []*PbOpLogEntry) ([]*PbOpLogEntry, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbOpLogEntry.Lock()
	defer object_slice_mu_PbOpLogEntry.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Name != v2.Name {
				continue
			}
			if v.Status != v2.Status {
				v.Status, changed = v2.Status, true
			}
			if v.Updated != v2.Updated {
				v.Updated, changed = v2.Updated, true
			}
			if v.Message != v2.Message {
				v.Message, changed = v2.Message, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_PbOpLogSets sync.RWMutex

func (it *PbOpLogSets) Equal(it2 *PbOpLogSets) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.Version != it2.Version ||
		!PbOpLogEntrySliceEqual(it.Items, it2.Items) {
		return false
	}
	return true
}

func (it *PbOpLogSets) Sync(it2 *PbOpLogSets) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.Version != it2.Version {
		it.Version, changed = it2.Version, true
	}
	if rs, ok := PbOpLogEntrySliceSyncSlice(it.Items, it2.Items); ok {
		it.Items, changed = rs, true
	}
	return changed
}

func PbOpLogSetsSliceGet(ls []*PbOpLogSets, arg_name string) *PbOpLogSets {
	object_slice_mu_PbOpLogSets.RLock()
	defer object_slice_mu_PbOpLogSets.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbOpLogSetsSliceEqual(ls, ls2 []*PbOpLogSets) bool {
	object_slice_mu_PbOpLogSets.RLock()
	defer object_slice_mu_PbOpLogSets.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if v.Version != v2.Version {
				return false
			}
			if !PbOpLogEntrySliceEqual(v.Items, v2.Items) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbOpLogSetsSliceSync(ls []*PbOpLogSets, it2 *PbOpLogSets) ([]*PbOpLogSets, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbOpLogSets.Lock()
	defer object_slice_mu_PbOpLogSets.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if v.Version != it2.Version {
			v.Version, changed = it2.Version, true
		}
		if rs, ok := PbOpLogEntrySliceSyncSlice(v.Items, it2.Items); ok {
			v.Items, changed = rs, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbOpLogSetsSliceSyncSlice(ls, ls2 []*PbOpLogSets) ([]*PbOpLogSets, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbOpLogSets.Lock()
	defer object_slice_mu_PbOpLogSets.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Name != v2.Name {
				continue
			}
			if v.Version != v2.Version {
				v.Version, changed = v2.Version, true
			}
			if rs, ok := PbOpLogEntrySliceSyncSlice(v.Items, v2.Items); ok {
				v.Items, changed = rs, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}
