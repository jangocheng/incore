// Code generated by github.com/hooto/protobuf_slice
// source: pod.proto
// DO NOT EDIT!

package inapi

import "sync"

var object_slice_mu_PbPodRepStatus sync.RWMutex

func (it *PbPodRepStatus) Equal(it2 *PbPodRepStatus) bool {
	if it2 == nil ||
		it.Id != it2.Id ||
		it.Rep != it2.Rep ||
		it.Phase != it2.Phase ||
		!PbPodBoxStatusSliceEqual(it.Boxes, it2.Boxes) ||
		it.Updated != it2.Updated {
		return false
	}
	return true
}

func (it *PbPodRepStatus) Sync(it2 *PbPodRepStatus) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Id != it2.Id {
		it.Id, changed = it2.Id, true
	}
	if it.Rep != it2.Rep {
		it.Rep, changed = it2.Rep, true
	}
	if it.Phase != it2.Phase {
		it.Phase, changed = it2.Phase, true
	}
	if rs, ok := PbPodBoxStatusSliceSyncSlice(it.Boxes, it2.Boxes); ok {
		it.Boxes, changed = rs, true
	}
	if it.Updated != it2.Updated {
		it.Updated, changed = it2.Updated, true
	}
	return changed
}

func PbPodRepStatusSliceGet(ls []*PbPodRepStatus, arg_id string, arg_rep uint32) *PbPodRepStatus {
	object_slice_mu_PbPodRepStatus.RLock()
	defer object_slice_mu_PbPodRepStatus.RUnlock()

	for _, v := range ls {
		if v.Id == arg_id && v.Rep == arg_rep {
			return v
		}
	}
	return nil
}

func PbPodRepStatusSliceEqual(ls, ls2 []*PbPodRepStatus) bool {
	object_slice_mu_PbPodRepStatus.RLock()
	defer object_slice_mu_PbPodRepStatus.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Id != v2.Id || v.Rep != v2.Rep {
				continue
			}
			if v.Phase != v2.Phase {
				return false
			}
			if !PbPodBoxStatusSliceEqual(v.Boxes, v2.Boxes) {
				return false
			}
			if v.Updated != v2.Updated {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbPodRepStatusSliceSync(ls []*PbPodRepStatus, it2 *PbPodRepStatus) ([]*PbPodRepStatus, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbPodRepStatus.Lock()
	defer object_slice_mu_PbPodRepStatus.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Id != it2.Id || v.Rep != it2.Rep {
			continue
		}
		if v.Phase != it2.Phase {
			v.Phase, changed = it2.Phase, true
		}
		if rs, ok := PbPodBoxStatusSliceSyncSlice(v.Boxes, it2.Boxes); ok {
			v.Boxes, changed = rs, true
		}
		if v.Updated != it2.Updated {
			v.Updated, changed = it2.Updated, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbPodRepStatusSliceSyncSlice(ls, ls2 []*PbPodRepStatus) ([]*PbPodRepStatus, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbPodRepStatus.Lock()
	defer object_slice_mu_PbPodRepStatus.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Id != v2.Id || v.Rep != v2.Rep {
				continue
			}
			if v.Phase != v2.Phase {
				v.Phase, changed = v2.Phase, true
			}
			if rs, ok := PbPodBoxStatusSliceSyncSlice(v.Boxes, v2.Boxes); ok {
				v.Boxes, changed = rs, true
			}
			if v.Updated != v2.Updated {
				v.Updated, changed = v2.Updated, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_PbVolumeMount sync.RWMutex

func (it *PbVolumeMount) Equal(it2 *PbVolumeMount) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.ReadOnly != it2.ReadOnly ||
		it.MountPath != it2.MountPath ||
		it.HostDir != it2.HostDir {
		return false
	}
	return true
}

func (it *PbVolumeMount) Sync(it2 *PbVolumeMount) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.ReadOnly != it2.ReadOnly {
		it.ReadOnly, changed = it2.ReadOnly, true
	}
	if it.MountPath != it2.MountPath {
		it.MountPath, changed = it2.MountPath, true
	}
	if it.HostDir != it2.HostDir {
		it.HostDir, changed = it2.HostDir, true
	}
	return changed
}

func PbVolumeMountSliceGet(ls []*PbVolumeMount, arg_mountpath string) *PbVolumeMount {
	object_slice_mu_PbVolumeMount.RLock()
	defer object_slice_mu_PbVolumeMount.RUnlock()

	for _, v := range ls {
		if v.MountPath == arg_mountpath {
			return v
		}
	}
	return nil
}

func PbVolumeMountSliceEqual(ls, ls2 []*PbVolumeMount) bool {
	object_slice_mu_PbVolumeMount.RLock()
	defer object_slice_mu_PbVolumeMount.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.MountPath != v2.MountPath {
				continue
			}
			if v.ReadOnly != v2.ReadOnly {
				return false
			}
			if v.HostDir != v2.HostDir {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbVolumeMountSliceSync(ls []*PbVolumeMount, it2 *PbVolumeMount) ([]*PbVolumeMount, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbVolumeMount.Lock()
	defer object_slice_mu_PbVolumeMount.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.MountPath != it2.MountPath {
			continue
		}
		if v.Name != it2.Name {
			v.Name, changed = it2.Name, true
		}
		if v.ReadOnly != it2.ReadOnly {
			v.ReadOnly, changed = it2.ReadOnly, true
		}
		if v.HostDir != it2.HostDir {
			v.HostDir, changed = it2.HostDir, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbVolumeMountSliceSyncSlice(ls, ls2 []*PbVolumeMount) ([]*PbVolumeMount, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbVolumeMount.Lock()
	defer object_slice_mu_PbVolumeMount.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.MountPath != v2.MountPath {
				continue
			}
			if v.Name != v2.Name {
				v.Name, changed = v2.Name, true
			}
			if v.ReadOnly != v2.ReadOnly {
				v.ReadOnly, changed = v2.ReadOnly, true
			}
			if v.HostDir != v2.HostDir {
				v.HostDir, changed = v2.HostDir, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_PbServicePort sync.RWMutex

func (it *PbServicePort) Equal(it2 *PbServicePort) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.BoxPort != it2.BoxPort ||
		it.HostPort != it2.HostPort {
		return false
	}
	return true
}

func (it *PbServicePort) Sync(it2 *PbServicePort) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.BoxPort != it2.BoxPort {
		it.BoxPort, changed = it2.BoxPort, true
	}
	if it.HostPort != it2.HostPort {
		it.HostPort, changed = it2.HostPort, true
	}
	return changed
}

func PbServicePortSliceGet(ls []*PbServicePort, arg_boxport uint32) *PbServicePort {
	object_slice_mu_PbServicePort.RLock()
	defer object_slice_mu_PbServicePort.RUnlock()

	for _, v := range ls {
		if v.BoxPort == arg_boxport {
			return v
		}
	}
	return nil
}

func PbServicePortSliceEqual(ls, ls2 []*PbServicePort) bool {
	object_slice_mu_PbServicePort.RLock()
	defer object_slice_mu_PbServicePort.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.BoxPort != v2.BoxPort {
				continue
			}
			if v.HostPort != v2.HostPort {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbServicePortSliceSync(ls []*PbServicePort, it2 *PbServicePort) ([]*PbServicePort, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbServicePort.Lock()
	defer object_slice_mu_PbServicePort.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.BoxPort != it2.BoxPort {
			continue
		}
		if v.Name != it2.Name {
			v.Name, changed = it2.Name, true
		}
		if v.HostPort != it2.HostPort {
			v.HostPort, changed = it2.HostPort, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbServicePortSliceSyncSlice(ls, ls2 []*PbServicePort) ([]*PbServicePort, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbServicePort.Lock()
	defer object_slice_mu_PbServicePort.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.BoxPort != v2.BoxPort {
				continue
			}
			if v.Name != v2.Name {
				v.Name, changed = v2.Name, true
			}
			if v.HostPort != v2.HostPort {
				v.HostPort, changed = v2.HostPort, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_PbPodBoxStatusExecutor sync.RWMutex

func (it *PbPodBoxStatusExecutor) Equal(it2 *PbPodBoxStatusExecutor) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.Phase != it2.Phase ||
		it.Retry != it2.Retry ||
		it.ErrorCode != it2.ErrorCode ||
		it.ErrorMessage != it2.ErrorMessage {
		return false
	}
	return true
}

func (it *PbPodBoxStatusExecutor) Sync(it2 *PbPodBoxStatusExecutor) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.Phase != it2.Phase {
		it.Phase, changed = it2.Phase, true
	}
	if it.Retry != it2.Retry {
		it.Retry, changed = it2.Retry, true
	}
	if it.ErrorCode != it2.ErrorCode {
		it.ErrorCode, changed = it2.ErrorCode, true
	}
	if it.ErrorMessage != it2.ErrorMessage {
		it.ErrorMessage, changed = it2.ErrorMessage, true
	}
	return changed
}

func PbPodBoxStatusExecutorSliceGet(ls []*PbPodBoxStatusExecutor, arg_name string) *PbPodBoxStatusExecutor {
	object_slice_mu_PbPodBoxStatusExecutor.RLock()
	defer object_slice_mu_PbPodBoxStatusExecutor.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbPodBoxStatusExecutorSliceEqual(ls, ls2 []*PbPodBoxStatusExecutor) bool {
	object_slice_mu_PbPodBoxStatusExecutor.RLock()
	defer object_slice_mu_PbPodBoxStatusExecutor.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if v.Phase != v2.Phase {
				return false
			}
			if v.Retry != v2.Retry {
				return false
			}
			if v.ErrorCode != v2.ErrorCode {
				return false
			}
			if v.ErrorMessage != v2.ErrorMessage {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbPodBoxStatusExecutorSliceSync(ls []*PbPodBoxStatusExecutor, it2 *PbPodBoxStatusExecutor) ([]*PbPodBoxStatusExecutor, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbPodBoxStatusExecutor.Lock()
	defer object_slice_mu_PbPodBoxStatusExecutor.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if v.Phase != it2.Phase {
			v.Phase, changed = it2.Phase, true
		}
		if v.Retry != it2.Retry {
			v.Retry, changed = it2.Retry, true
		}
		if v.ErrorCode != it2.ErrorCode {
			v.ErrorCode, changed = it2.ErrorCode, true
		}
		if v.ErrorMessage != it2.ErrorMessage {
			v.ErrorMessage, changed = it2.ErrorMessage, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbPodBoxStatusExecutorSliceSyncSlice(ls, ls2 []*PbPodBoxStatusExecutor) ([]*PbPodBoxStatusExecutor, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbPodBoxStatusExecutor.Lock()
	defer object_slice_mu_PbPodBoxStatusExecutor.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Name != v2.Name {
				continue
			}
			if v.Phase != v2.Phase {
				v.Phase, changed = v2.Phase, true
			}
			if v.Retry != v2.Retry {
				v.Retry, changed = v2.Retry, true
			}
			if v.ErrorCode != v2.ErrorCode {
				v.ErrorCode, changed = v2.ErrorCode, true
			}
			if v.ErrorMessage != v2.ErrorMessage {
				v.ErrorMessage, changed = v2.ErrorMessage, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_PbPodBoxStatus sync.RWMutex

func (it *PbPodBoxStatus) Equal(it2 *PbPodBoxStatus) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.ImageDriver != it2.ImageDriver ||
		!LabelSliceEqual(it.ImageOptions, it2.ImageOptions) ||
		it.ResCpuLimit != it2.ResCpuLimit ||
		it.ResMemLimit != it2.ResMemLimit ||
		!PbVolumeMountSliceEqual(it.Mounts, it2.Mounts) ||
		!PbServicePortSliceEqual(it.Ports, it2.Ports) ||
		!PbPodBoxStatusExecutorSliceEqual(it.Executors, it2.Executors) ||
		it.Phase != it2.Phase ||
		it.Started != it2.Started ||
		it.Updated != it2.Updated {
		return false
	}
	return true
}

func (it *PbPodBoxStatus) Sync(it2 *PbPodBoxStatus) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.ImageDriver != it2.ImageDriver {
		it.ImageDriver, changed = it2.ImageDriver, true
	}
	if rs, ok := LabelSliceSyncSlice(it.ImageOptions, it2.ImageOptions); ok {
		it.ImageOptions, changed = rs, true
	}
	if it.ResCpuLimit != it2.ResCpuLimit {
		it.ResCpuLimit, changed = it2.ResCpuLimit, true
	}
	if it.ResMemLimit != it2.ResMemLimit {
		it.ResMemLimit, changed = it2.ResMemLimit, true
	}
	if rs, ok := PbVolumeMountSliceSyncSlice(it.Mounts, it2.Mounts); ok {
		it.Mounts, changed = rs, true
	}
	if rs, ok := PbServicePortSliceSyncSlice(it.Ports, it2.Ports); ok {
		it.Ports, changed = rs, true
	}
	if rs, ok := PbPodBoxStatusExecutorSliceSyncSlice(it.Executors, it2.Executors); ok {
		it.Executors, changed = rs, true
	}
	if it.Phase != it2.Phase {
		it.Phase, changed = it2.Phase, true
	}
	if it.Started != it2.Started {
		it.Started, changed = it2.Started, true
	}
	if it.Updated != it2.Updated {
		it.Updated, changed = it2.Updated, true
	}
	return changed
}

func PbPodBoxStatusSliceGet(ls []*PbPodBoxStatus, arg_name string) *PbPodBoxStatus {
	object_slice_mu_PbPodBoxStatus.RLock()
	defer object_slice_mu_PbPodBoxStatus.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbPodBoxStatusSliceEqual(ls, ls2 []*PbPodBoxStatus) bool {
	object_slice_mu_PbPodBoxStatus.RLock()
	defer object_slice_mu_PbPodBoxStatus.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if v.ImageDriver != v2.ImageDriver {
				return false
			}
			if !LabelSliceEqual(v.ImageOptions, v2.ImageOptions) {
				return false
			}
			if v.ResCpuLimit != v2.ResCpuLimit {
				return false
			}
			if v.ResMemLimit != v2.ResMemLimit {
				return false
			}
			if !PbVolumeMountSliceEqual(v.Mounts, v2.Mounts) {
				return false
			}
			if !PbServicePortSliceEqual(v.Ports, v2.Ports) {
				return false
			}
			if !PbPodBoxStatusExecutorSliceEqual(v.Executors, v2.Executors) {
				return false
			}
			if v.Phase != v2.Phase {
				return false
			}
			if v.Started != v2.Started {
				return false
			}
			if v.Updated != v2.Updated {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbPodBoxStatusSliceSync(ls []*PbPodBoxStatus, it2 *PbPodBoxStatus) ([]*PbPodBoxStatus, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbPodBoxStatus.Lock()
	defer object_slice_mu_PbPodBoxStatus.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if v.ImageDriver != it2.ImageDriver {
			v.ImageDriver, changed = it2.ImageDriver, true
		}
		if rs, ok := LabelSliceSyncSlice(v.ImageOptions, it2.ImageOptions); ok {
			v.ImageOptions, changed = rs, true
		}
		if v.ResCpuLimit != it2.ResCpuLimit {
			v.ResCpuLimit, changed = it2.ResCpuLimit, true
		}
		if v.ResMemLimit != it2.ResMemLimit {
			v.ResMemLimit, changed = it2.ResMemLimit, true
		}
		if rs, ok := PbVolumeMountSliceSyncSlice(v.Mounts, it2.Mounts); ok {
			v.Mounts, changed = rs, true
		}
		if rs, ok := PbServicePortSliceSyncSlice(v.Ports, it2.Ports); ok {
			v.Ports, changed = rs, true
		}
		if rs, ok := PbPodBoxStatusExecutorSliceSyncSlice(v.Executors, it2.Executors); ok {
			v.Executors, changed = rs, true
		}
		if v.Phase != it2.Phase {
			v.Phase, changed = it2.Phase, true
		}
		if v.Started != it2.Started {
			v.Started, changed = it2.Started, true
		}
		if v.Updated != it2.Updated {
			v.Updated, changed = it2.Updated, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbPodBoxStatusSliceSyncSlice(ls, ls2 []*PbPodBoxStatus) ([]*PbPodBoxStatus, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbPodBoxStatus.Lock()
	defer object_slice_mu_PbPodBoxStatus.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Name != v2.Name {
				continue
			}
			if v.ImageDriver != v2.ImageDriver {
				v.ImageDriver, changed = v2.ImageDriver, true
			}
			if rs, ok := LabelSliceSyncSlice(v.ImageOptions, v2.ImageOptions); ok {
				v.ImageOptions, changed = rs, true
			}
			if v.ResCpuLimit != v2.ResCpuLimit {
				v.ResCpuLimit, changed = v2.ResCpuLimit, true
			}
			if v.ResMemLimit != v2.ResMemLimit {
				v.ResMemLimit, changed = v2.ResMemLimit, true
			}
			if rs, ok := PbVolumeMountSliceSyncSlice(v.Mounts, v2.Mounts); ok {
				v.Mounts, changed = rs, true
			}
			if rs, ok := PbServicePortSliceSyncSlice(v.Ports, v2.Ports); ok {
				v.Ports, changed = rs, true
			}
			if rs, ok := PbPodBoxStatusExecutorSliceSyncSlice(v.Executors, v2.Executors); ok {
				v.Executors, changed = rs, true
			}
			if v.Phase != v2.Phase {
				v.Phase, changed = v2.Phase, true
			}
			if v.Started != v2.Started {
				v.Started, changed = v2.Started, true
			}
			if v.Updated != v2.Updated {
				v.Updated, changed = v2.Updated, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}

var object_slice_mu_PbOpLogEntry sync.RWMutex

func (it *PbOpLogEntry) Equal(it2 *PbOpLogEntry) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.Message != it2.Message ||
		it.Created != it2.Created ||
		it.Updated != it2.Updated {
		return false
	}
	return true
}

func (it *PbOpLogEntry) Sync(it2 *PbOpLogEntry) bool {
	if it2 == nil {
		return false
	}
	changed := false
	if it.Name != it2.Name {
		it.Name, changed = it2.Name, true
	}
	if it.Message != it2.Message {
		it.Message, changed = it2.Message, true
	}
	if it.Created != it2.Created {
		it.Created, changed = it2.Created, true
	}
	if it.Updated != it2.Updated {
		it.Updated, changed = it2.Updated, true
	}
	return changed
}

func PbOpLogEntrySliceGet(ls []*PbOpLogEntry, arg_name string) *PbOpLogEntry {
	object_slice_mu_PbOpLogEntry.RLock()
	defer object_slice_mu_PbOpLogEntry.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbOpLogEntrySliceEqual(ls, ls2 []*PbOpLogEntry) bool {
	object_slice_mu_PbOpLogEntry.RLock()
	defer object_slice_mu_PbOpLogEntry.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if v.Message != v2.Message {
				return false
			}
			if v.Created != v2.Created {
				return false
			}
			if v.Updated != v2.Updated {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbOpLogEntrySliceSync(ls []*PbOpLogEntry, it2 *PbOpLogEntry) ([]*PbOpLogEntry, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbOpLogEntry.Lock()
	defer object_slice_mu_PbOpLogEntry.Unlock()

	hit := false
	changed := false
	for _, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if v.Message != it2.Message {
			v.Message, changed = it2.Message, true
		}
		if v.Created != it2.Created {
			v.Created, changed = it2.Created, true
		}
		if v.Updated != it2.Updated {
			v.Updated, changed = it2.Updated, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbOpLogEntrySliceSyncSlice(ls, ls2 []*PbOpLogEntry) ([]*PbOpLogEntry, bool) {
	if len(ls2) == 0 {
		return ls, false
	}
	object_slice_mu_PbOpLogEntry.Lock()
	defer object_slice_mu_PbOpLogEntry.Unlock()

	hit := false
	changed := false
	for _, v2 := range ls2 {
		hit = false
		for _, v := range ls {
			if v.Name != v2.Name {
				continue
			}
			if v.Message != v2.Message {
				v.Message, changed = v2.Message, true
			}
			if v.Created != v2.Created {
				v.Created, changed = v2.Created, true
			}
			if v.Updated != v2.Updated {
				v.Updated, changed = v2.Updated, true
			}
			hit = true
			break
		}
		if !hit {
			ls = append(ls, v2)
			changed = true
		}
	}
	return ls, changed
}
