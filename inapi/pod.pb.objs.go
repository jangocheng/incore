// Code generated by github.com/hooto/protobuf_slice
// source: pod.proto
// DO NOT EDIT!

package inapi

import "sync"

var object_slice_mu_HealthStatus sync.RWMutex

func (it *HealthStatus) Equal(it2 *HealthStatus) bool {
	if it2 == nil ||
		it.PartId != it2.PartId ||
		it.Action != it2.Action ||
		it.Updated != it2.Updated ||
		it.Message != it2.Message {
		return false
	}
	return true
}

func (it *HealthStatus) Sync(it2 *HealthStatus) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func HealthStatusSliceGet(ls []*HealthStatus, arg_partid uint32) *HealthStatus {
	object_slice_mu_HealthStatus.RLock()
	defer object_slice_mu_HealthStatus.RUnlock()

	for _, v := range ls {
		if v.PartId == arg_partid {
			return v
		}
	}
	return nil
}

func HealthStatusSliceDel(ls []*HealthStatus, arg_partid uint32) ([]*HealthStatus, bool) {
	object_slice_mu_HealthStatus.Lock()
	defer object_slice_mu_HealthStatus.Unlock()
	for i, v := range ls {
		if v.PartId == arg_partid {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func HealthStatusSliceEqual(ls, ls2 []*HealthStatus) bool {
	object_slice_mu_HealthStatus.RLock()
	defer object_slice_mu_HealthStatus.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.PartId != v2.PartId {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func HealthStatusSliceSync(ls []*HealthStatus, it2 *HealthStatus) ([]*HealthStatus, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_HealthStatus.Lock()
	defer object_slice_mu_HealthStatus.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.PartId != it2.PartId {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func HealthStatusSliceSyncSlice(ls, ls2 []*HealthStatus) ([]*HealthStatus, bool) {
	if HealthStatusSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbPodRepStatus sync.RWMutex

func (it *PbPodRepStatus) Equal(it2 *PbPodRepStatus) bool {
	if it2 == nil ||
		it.PodId != it2.PodId ||
		it.RepId != it2.RepId ||
		it.Action != it2.Action ||
		it.Node != it2.Node ||
		(it.OpLog == nil && it2.OpLog != nil) ||
		(it.OpLog != nil && !it.OpLog.Equal(it2.OpLog)) ||
		(it.Stats == nil && it2.Stats != nil) ||
		(it.Stats != nil && !it.Stats.Equal(it2.Stats)) ||
		it.Updated != it2.Updated ||
		!PbVolumeStatusSliceEqual(it.Volumes, it2.Volumes) ||
		it.Started != it2.Started ||
		!PbServicePortSliceEqual(it.Ports, it2.Ports) ||
		(it.Health == nil && it2.Health != nil) ||
		(it.Health != nil && !it.Health.Equal(it2.Health)) {
		return false
	}
	return true
}

func (it *PbPodRepStatus) Sync(it2 *PbPodRepStatus) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbPodRepStatusSliceGet(ls []*PbPodRepStatus, arg_podid string, arg_repid uint32) *PbPodRepStatus {
	object_slice_mu_PbPodRepStatus.RLock()
	defer object_slice_mu_PbPodRepStatus.RUnlock()

	for _, v := range ls {
		if v.PodId == arg_podid && v.RepId == arg_repid {
			return v
		}
	}
	return nil
}

func PbPodRepStatusSliceDel(ls []*PbPodRepStatus, arg_podid string, arg_repid uint32) ([]*PbPodRepStatus, bool) {
	object_slice_mu_PbPodRepStatus.Lock()
	defer object_slice_mu_PbPodRepStatus.Unlock()
	for i, v := range ls {
		if v.PodId == arg_podid && v.RepId == arg_repid {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbPodRepStatusSliceEqual(ls, ls2 []*PbPodRepStatus) bool {
	object_slice_mu_PbPodRepStatus.RLock()
	defer object_slice_mu_PbPodRepStatus.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.PodId != v2.PodId || v.RepId != v2.RepId {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbPodRepStatusSliceSync(ls []*PbPodRepStatus, it2 *PbPodRepStatus) ([]*PbPodRepStatus, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbPodRepStatus.Lock()
	defer object_slice_mu_PbPodRepStatus.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.PodId != it2.PodId || v.RepId != it2.RepId {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbPodRepStatusSliceSyncSlice(ls, ls2 []*PbPodRepStatus) ([]*PbPodRepStatus, bool) {
	if PbPodRepStatusSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbVolumeMount sync.RWMutex

func (it *PbVolumeMount) Equal(it2 *PbVolumeMount) bool {
	if it2 == nil ||
		it.ReadOnly != it2.ReadOnly ||
		it.MountPath != it2.MountPath ||
		it.HostDir != it2.HostDir {
		return false
	}
	return true
}

func (it *PbVolumeMount) Sync(it2 *PbVolumeMount) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbVolumeMountSliceGet(ls []*PbVolumeMount, arg_mountpath string) *PbVolumeMount {
	object_slice_mu_PbVolumeMount.RLock()
	defer object_slice_mu_PbVolumeMount.RUnlock()

	for _, v := range ls {
		if v.MountPath == arg_mountpath {
			return v
		}
	}
	return nil
}

func PbVolumeMountSliceDel(ls []*PbVolumeMount, arg_mountpath string) ([]*PbVolumeMount, bool) {
	object_slice_mu_PbVolumeMount.Lock()
	defer object_slice_mu_PbVolumeMount.Unlock()
	for i, v := range ls {
		if v.MountPath == arg_mountpath {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbVolumeMountSliceEqual(ls, ls2 []*PbVolumeMount) bool {
	object_slice_mu_PbVolumeMount.RLock()
	defer object_slice_mu_PbVolumeMount.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.MountPath != v2.MountPath {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbVolumeMountSliceSync(ls []*PbVolumeMount, it2 *PbVolumeMount) ([]*PbVolumeMount, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbVolumeMount.Lock()
	defer object_slice_mu_PbVolumeMount.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.MountPath != it2.MountPath {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbVolumeMountSliceSyncSlice(ls, ls2 []*PbVolumeMount) ([]*PbVolumeMount, bool) {
	if PbVolumeMountSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbVolumeStatus sync.RWMutex

func (it *PbVolumeStatus) Equal(it2 *PbVolumeStatus) bool {
	if it2 == nil ||
		it.MountPath != it2.MountPath ||
		it.Used != it2.Used {
		return false
	}
	return true
}

func (it *PbVolumeStatus) Sync(it2 *PbVolumeStatus) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbVolumeStatusSliceGet(ls []*PbVolumeStatus, arg_mountpath string) *PbVolumeStatus {
	object_slice_mu_PbVolumeStatus.RLock()
	defer object_slice_mu_PbVolumeStatus.RUnlock()

	for _, v := range ls {
		if v.MountPath == arg_mountpath {
			return v
		}
	}
	return nil
}

func PbVolumeStatusSliceDel(ls []*PbVolumeStatus, arg_mountpath string) ([]*PbVolumeStatus, bool) {
	object_slice_mu_PbVolumeStatus.Lock()
	defer object_slice_mu_PbVolumeStatus.Unlock()
	for i, v := range ls {
		if v.MountPath == arg_mountpath {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbVolumeStatusSliceEqual(ls, ls2 []*PbVolumeStatus) bool {
	object_slice_mu_PbVolumeStatus.RLock()
	defer object_slice_mu_PbVolumeStatus.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.MountPath != v2.MountPath {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbVolumeStatusSliceSync(ls []*PbVolumeStatus, it2 *PbVolumeStatus) ([]*PbVolumeStatus, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbVolumeStatus.Lock()
	defer object_slice_mu_PbVolumeStatus.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.MountPath != it2.MountPath {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbVolumeStatusSliceSyncSlice(ls, ls2 []*PbVolumeStatus) ([]*PbVolumeStatus, bool) {
	if PbVolumeStatusSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbServicePort sync.RWMutex

func (it *PbServicePort) Equal(it2 *PbServicePort) bool {
	if it2 == nil ||
		it.BoxPort != it2.BoxPort ||
		it.HostPort != it2.HostPort {
		return false
	}
	return true
}

func (it *PbServicePort) Sync(it2 *PbServicePort) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbServicePortSliceGet(ls []*PbServicePort, arg_boxport uint32) *PbServicePort {
	object_slice_mu_PbServicePort.RLock()
	defer object_slice_mu_PbServicePort.RUnlock()

	for _, v := range ls {
		if v.BoxPort == arg_boxport {
			return v
		}
	}
	return nil
}

func PbServicePortSliceDel(ls []*PbServicePort, arg_boxport uint32) ([]*PbServicePort, bool) {
	object_slice_mu_PbServicePort.Lock()
	defer object_slice_mu_PbServicePort.Unlock()
	for i, v := range ls {
		if v.BoxPort == arg_boxport {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbServicePortSliceEqual(ls, ls2 []*PbServicePort) bool {
	object_slice_mu_PbServicePort.RLock()
	defer object_slice_mu_PbServicePort.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.BoxPort != v2.BoxPort {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbServicePortSliceSync(ls []*PbServicePort, it2 *PbServicePort) ([]*PbServicePort, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbServicePort.Lock()
	defer object_slice_mu_PbServicePort.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.BoxPort != it2.BoxPort {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbServicePortSliceSyncSlice(ls, ls2 []*PbServicePort) ([]*PbServicePort, bool) {
	if PbServicePortSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbPodBoxStatusExecutor sync.RWMutex

func (it *PbPodBoxStatusExecutor) Equal(it2 *PbPodBoxStatusExecutor) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.Phase != it2.Phase ||
		it.Retry != it2.Retry ||
		it.ErrorCode != it2.ErrorCode ||
		it.ErrorMessage != it2.ErrorMessage {
		return false
	}
	return true
}

func (it *PbPodBoxStatusExecutor) Sync(it2 *PbPodBoxStatusExecutor) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbPodBoxStatusExecutorSliceGet(ls []*PbPodBoxStatusExecutor, arg_name string) *PbPodBoxStatusExecutor {
	object_slice_mu_PbPodBoxStatusExecutor.RLock()
	defer object_slice_mu_PbPodBoxStatusExecutor.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbPodBoxStatusExecutorSliceDel(ls []*PbPodBoxStatusExecutor, arg_name string) ([]*PbPodBoxStatusExecutor, bool) {
	object_slice_mu_PbPodBoxStatusExecutor.Lock()
	defer object_slice_mu_PbPodBoxStatusExecutor.Unlock()
	for i, v := range ls {
		if v.Name == arg_name {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbPodBoxStatusExecutorSliceEqual(ls, ls2 []*PbPodBoxStatusExecutor) bool {
	object_slice_mu_PbPodBoxStatusExecutor.RLock()
	defer object_slice_mu_PbPodBoxStatusExecutor.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbPodBoxStatusExecutorSliceSync(ls []*PbPodBoxStatusExecutor, it2 *PbPodBoxStatusExecutor) ([]*PbPodBoxStatusExecutor, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbPodBoxStatusExecutor.Lock()
	defer object_slice_mu_PbPodBoxStatusExecutor.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbPodBoxStatusExecutorSliceSyncSlice(ls, ls2 []*PbPodBoxStatusExecutor) ([]*PbPodBoxStatusExecutor, bool) {
	if PbPodBoxStatusExecutorSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PbPodBoxStatus sync.RWMutex

func (it *PbPodBoxStatus) Equal(it2 *PbPodBoxStatus) bool {
	if it2 == nil ||
		it.Name != it2.Name ||
		it.ImageDriver != it2.ImageDriver ||
		!LabelSliceEqual(it.ImageOptions, it2.ImageOptions) ||
		it.ResCpuLimit != it2.ResCpuLimit ||
		it.ResMemLimit != it2.ResMemLimit ||
		!PbVolumeMountSliceEqual(it.Mounts, it2.Mounts) ||
		!PbServicePortSliceEqual(it.Ports, it2.Ports) ||
		!PbStringSliceEqual(it.Command, it2.Command) ||
		!PbPodBoxStatusExecutorSliceEqual(it.Executors, it2.Executors) ||
		it.Action != it2.Action ||
		it.Started != it2.Started ||
		it.Updated != it2.Updated ||
		!PbInt32SliceEqual(it.CpuSets, it2.CpuSets) ||
		it.NetworkMode != it2.NetworkMode {
		return false
	}
	return true
}

func (it *PbPodBoxStatus) Sync(it2 *PbPodBoxStatus) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PbPodBoxStatusSliceGet(ls []*PbPodBoxStatus, arg_name string) *PbPodBoxStatus {
	object_slice_mu_PbPodBoxStatus.RLock()
	defer object_slice_mu_PbPodBoxStatus.RUnlock()

	for _, v := range ls {
		if v.Name == arg_name {
			return v
		}
	}
	return nil
}

func PbPodBoxStatusSliceDel(ls []*PbPodBoxStatus, arg_name string) ([]*PbPodBoxStatus, bool) {
	object_slice_mu_PbPodBoxStatus.Lock()
	defer object_slice_mu_PbPodBoxStatus.Unlock()
	for i, v := range ls {
		if v.Name == arg_name {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PbPodBoxStatusSliceEqual(ls, ls2 []*PbPodBoxStatus) bool {
	object_slice_mu_PbPodBoxStatus.RLock()
	defer object_slice_mu_PbPodBoxStatus.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Name != v2.Name {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PbPodBoxStatusSliceSync(ls []*PbPodBoxStatus, it2 *PbPodBoxStatus) ([]*PbPodBoxStatus, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PbPodBoxStatus.Lock()
	defer object_slice_mu_PbPodBoxStatus.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.Name != it2.Name {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PbPodBoxStatusSliceSyncSlice(ls, ls2 []*PbPodBoxStatus) ([]*PbPodBoxStatus, bool) {
	if PbPodBoxStatusSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_PodOperateFailoverReplica sync.RWMutex

func (it *PodOperateFailoverReplica) Equal(it2 *PodOperateFailoverReplica) bool {
	if it2 == nil ||
		it.RepId != it2.RepId ||
		it.ManualChecked != it2.ManualChecked ||
		it.Created != it2.Created ||
		it.Updated != it2.Updated {
		return false
	}
	return true
}

func (it *PodOperateFailoverReplica) Sync(it2 *PodOperateFailoverReplica) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func PodOperateFailoverReplicaSliceGet(ls []*PodOperateFailoverReplica, arg_repid uint32) *PodOperateFailoverReplica {
	object_slice_mu_PodOperateFailoverReplica.RLock()
	defer object_slice_mu_PodOperateFailoverReplica.RUnlock()

	for _, v := range ls {
		if v.RepId == arg_repid {
			return v
		}
	}
	return nil
}

func PodOperateFailoverReplicaSliceDel(ls []*PodOperateFailoverReplica, arg_repid uint32) ([]*PodOperateFailoverReplica, bool) {
	object_slice_mu_PodOperateFailoverReplica.Lock()
	defer object_slice_mu_PodOperateFailoverReplica.Unlock()
	for i, v := range ls {
		if v.RepId == arg_repid {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func PodOperateFailoverReplicaSliceEqual(ls, ls2 []*PodOperateFailoverReplica) bool {
	object_slice_mu_PodOperateFailoverReplica.RLock()
	defer object_slice_mu_PodOperateFailoverReplica.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.RepId != v2.RepId {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func PodOperateFailoverReplicaSliceSync(ls []*PodOperateFailoverReplica, it2 *PodOperateFailoverReplica) ([]*PodOperateFailoverReplica, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_PodOperateFailoverReplica.Lock()
	defer object_slice_mu_PodOperateFailoverReplica.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.RepId != it2.RepId {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func PodOperateFailoverReplicaSliceSyncSlice(ls, ls2 []*PodOperateFailoverReplica) ([]*PodOperateFailoverReplica, bool) {
	if PodOperateFailoverReplicaSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}
